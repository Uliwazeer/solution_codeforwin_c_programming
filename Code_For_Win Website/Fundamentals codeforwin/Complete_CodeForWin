نموذج البرمجة هو طريقة لتصنيف لغات البرمجة وفقًا لأسلوب البرمجة الخاص بها والميزات التي تقدمها. هناك العديد من الميزات التي تحدد نموذج البرمجة مثل النمطية أو الكائنات أو المقاطعات أو الأحداث أو تدفق التحكم وما إلى ذلك. يمكن أن تكون لغة البرمجة نموذجًا واحدًا أو نماذج متعددة.

ومع الانتشار الواسع للبرمجة، ظهرت نماذج برمجة مختلفة إلى الوجود. بعض نماذج البرمجة الشائعة هي:

البرمجة الحتمية
البرمجة الحتمية هي أقدم نموذج ولا تزال قيد التنفيذ. إنه النموذج الممارس على نطاق واسع في البرمجة اليومية. وهو يركز بشكل أساسي على الخطوات التي يجب القيام بها ويعمل على منطق "افعل هذا أولاً ثم افعل ذلك". فهو يحدد سلسلة من البيانات التي يجب أن تتم العمليات بالترتيب. في البرمجة الحتمية، يكون تدفق التحكم واضحًا ويعتمد على مجموعة عبارات GOTO. البرمجة الحتمية تفتقر إلى دعم النمطية.

من أمثلة لغات البرمجة الحتمية – Assembly وC وC++ وJava وما إلى ذلك.


فيما يلي نهج البرمجة الحتمي لإدراج الاسم الأول والأخير للطلاب من قائمة الطلاب الذين تزيد درجاتهم عن 90.
*********************************************************************************************************************************************
اللغة منخفضة المستوى والمختصرة بـ LLL، هي لغات قريبة من مجموعة تعليمات مستوى الآلة. أنها توفر تجريدًا أقل أو معدومة من الأجهزة. تتفاعل لغة برمجة منخفضة المستوى مباشرة مع السجلات والذاكرة. نظرًا لأن التعليمات المكتوبة بلغات منخفضة المستوى تعتمد على الآلة. البرامج التي تم تطويرها باستخدام لغات منخفضة المستوى تعتمد على الآلة وليست محمولة.


لا تتطلب اللغة ذات المستوى المنخفض أي مترجم أو مترجم فوري لترجمة المصدر إلى كود الآلة. قد يقوم المجمع بترجمة كود المصدر المكتوب بلغة منخفضة المستوى إلى كود الآلة.

البرامج المكتوبة بلغات منخفضة المستوى سريعة وفعالة في الذاكرة. ومع ذلك، فمن الكابوس بالنسبة للمبرمجين كتابة البرامج ذات المستوى المنخفض وتصحيح أخطائها وصيانتها. يتم استخدامها في الغالب لتطوير أنظمة التشغيل وبرامج تشغيل الأجهزة وقواعد البيانات والتطبيقات التي تتطلب الوصول المباشر إلى الأجهزة.

يتم تصنيف اللغات منخفضة المستوى أيضًا إلى فئتين أخريين – لغة الآلة ولغة التجميع.
*********************************************************************************************************************************************
مميزات اللغات ذات المستوى المنخفض
البرامج التي تم تطويرها باستخدام لغات منخفضة المستوى سريعة وفعالة في الذاكرة.
يمكن للمبرمجين الاستفادة من المعالج والذاكرة بطريقة أفضل باستخدام لغة منخفضة المستوى.
ليست هناك حاجة لأي مترجم أو مترجمين فوريين لترجمة المصدر إلى كود الآلة. وبالتالي، يختصر وقت التجميع والترجمة.
توفر اللغات ذات المستوى المنخفض معالجة مباشرة لسجلات الكمبيوتر وتخزينه.
يمكنه التواصل مباشرة مع الأجهزة.
*********************************************************************************************************************************************
Disadvantages of High level language
It takes additional translation times to translate the source to machine code.
High level programs are comparatively slower than low level programs.
Compared to low level programs, they are generally less memory efficient.
Cannot communicate directly with the hardware.
Low level languages – advantages and disadvantages
********************************************************************************************************
Advantages of High level language
High level languages are programmer friendly. They are easy to write, debug and maintain.
It provide higher level of abstraction from machine languages.
It is machine independent language.
Easy to learn.
Less error prone, easy to find and debug errors.
High level programming results in better programming productivity.
*********************************************************************************************************
يتم اختصار اللغة عالية المستوى كـ HLL. اللغات عالية المستوى تشبه اللغة البشرية. على عكس اللغات ذات المستوى المنخفض، تعد اللغات عالية المستوى صديقة للمبرمجين، وسهلة البرمجة والتصحيح والصيانة.

توفر اللغة عالية المستوى مستوى أعلى من التجريد من لغة الآلة. أنها لا تتفاعل مباشرة مع الأجهزة. وبدلاً من ذلك، يركزون أكثر على العمليات الحسابية المعقدة وكفاءة البرنامج المثلى وسهولة البرمجة.


تستخدم البرمجة ذات المستوى المنخفض لغة صديقة للآلة. يكتب المبرمجون التعليمات البرمجية إما باللغة الثنائية أو لغة التجميع. تعد كتابة البرامج بالنظام الثنائي عملية معقدة ومرهقة. وبالتالي، لجعل البرمجة أكثر ودية للمبرمجين. تتم كتابة البرامج باللغة عالية المستوى باستخدام عبارات اللغة الإنجليزية.

تتطلب البرامج عالية المستوى مترجمين/مترجمين فوريين لترجمة كود المصدر إلى لغة الآلة. يمكننا تجميع كود المصدر المكتوب بلغة عالية المستوى إلى لغات الآلة المتعددة. وبالتالي، فهي لغة مستقلة عن الآلة.

اليوم يتم تطوير جميع البرامج تقريبًا باستخدام لغة برمجة عالية المستوى. يمكننا تطوير مجموعة متنوعة من التطبيقات باستخدام لغة عالية المستوى. يتم استخدامها لتطوير تطبيقات سطح المكتب ومواقع الويب وبرامج النظام وبرامج المرافق وغيرها الكثير.

يتم تجميع اللغات عالية المستوى في فئتين بناءً على نموذج التنفيذ – اللغات المجمعة أو المفسرة.
*********************************************************************************************************************************************
سرعة البرنامج
تتم كتابة البرامج ذات اللغة منخفضة المستوى إما باللغة الثنائية أو لغة التجميع. أنها لا تتطلب أي تجميع أو تفسير. تتفاعل مباشرة مع السجلات والذاكرة. وبالتالي، فهي أسرع نسبيًا من اللغات عالية المستوى.

تستخدم اللغة عالية المستوى عبارات اللغة الإنجليزية لكتابة البرامج. ومن ثم، فهم يحتاجون إلى مترجمين أو مترجمين فوريين لترجمة المصدر إلى لغة الآلة. أنها لا تتفاعل مباشرة مع الأجهزة. وبالتالي فهي أبطأ من اللغات ذات المستوى المنخفض.
*********************************************************************************************************************************************
كفاءة الذاكرة
اللغات ذات المستوى المنخفض فعالة في الذاكرة. وهي تستهلك بشكل عام ذاكرة أقل.

اللغات عالية المستوى ليست ذات كفاءة في الذاكرة. يتم تشغيلها بشكل عام داخل بيئة تشغيل محددة. كما أن هناك عدة برامج أخرى تعمل بشكل متزامن لزيادة الكفاءة المثلى للبرنامج الذي يستهلك الذاكرة. وبالتالي، فإن استهلاك الذاكرة الإجمالي للغة عالية المستوى أكبر نسبيًا من اللغة منخفضة المستوى.
*********************************************************************************************************************************************
سهولة
اللغات ذات المستوى المنخفض هي لغات صديقة للآلة. لكتابة برنامج بلغة منخفضة المستوى، يجب أن نعرف الثنائيات أو أساليب الإستذكار لمجموعات التعليمات ذات المستوى المنخفض. إن تذكر مجموعات التعليمات المختلفة للبنى المختلفة يكاد يكون مستحيلاً. وبالتالي، يصعب تعلم البرمجة ذات المستوى المنخفض. يتطلب تعلم اللغات ذات المستوى المنخفض معرفة وخبرة إضافية حول بنية الآلة المحددة.

اللغات عالية المستوى هي لغة صديقة للمبرمجين. تتم كتابة البرامج ذات اللغة عالية المستوى باستخدام عبارات اللغة الإنجليزية. وهو أمر أسهل بكثير في التذكر من الثنائيات أو أساليب تقوية الذاكرة ذات المستوى المنخفض. وبالتالي، فإن البرمجة عالية المستوى سهلة التعلم.

قابلية التنقل
لغة منخفضة المستوى تحتوي على مجموعة تعليمات حاسوبية منخفضة المستوى. تعتمد هذه التعليمات على الآلة وتختلف باختلاف البنيات. ومن ثم، فإن البرامج التي تم تطويرها تعتمد أيضًا على الآلة وليست محمولة.

تستخدم اللغات عالية المستوى عبارات اللغة الإنجليزية لكتابة البرامج. ويتم ترجمتها أيضًا إلى لغة الآلة باستخدام مترجم أو مترجم. يوجد مترجم أو مترجم منفصل لبنيات الآلة المختلفة. وهذا يترجم المصدر إلى لغة آلة محددة. ومن ثم، فإن اللغات عالية المستوى مستقلة عن الآلة ومحمولة.

مستوى التجريد
توفر اللغة ذات المستوى المنخفض تجريدًا أقل أو معدومة من الأجهزة. إنها اللغة الأقرب إلى الأجهزة. أنها تتفاعل مباشرة مع تسجيل أجهزة الكمبيوتر والذاكرة.

توفر اللغة عالية المستوى مستوى عالٍ من التجريد من الأجهزة. أنها تعمل على رأس لغة الآلة. أنها لا تتفاعل مباشرة مع تسجيل أجهزة الكمبيوتر والذاكرة. هناك طبقة من نظام التشغيل والبرامج الأخرى التي تتفاعل من خلالها مع الأجهزة.

تصحيح الأخطاء والصيانة
اللغات ذات المستوى المنخفض أكثر عرضة للخطأ. من الأخطاء النحوية الصغيرة إلى تسرب الذاكرة الكبيرة. يعد اكتشاف الأخطاء وصيانتها عملية شاقة وتستغرق وقتًا طويلاً.

اللغات عالية المستوى أقل عرضة للخطأ. يتم تحديد جميع الأخطاء النحوية تقريبًا باستخدام المترجمين أو المترجمين الفوريين. فهي سهلة التصحيح والصيانة بشكل عام.

المعرفة والخبرة الإضافية
اللغات ذات المستوى المنخفض تعتمد على الآلة. أنها تتطلب معرفة مسبقة بهندسة الكمبيوتر معينة. قبل أن يتمكن المرء فعليًا من كتابة برنامج لهذا الكمبيوتر.

اللغات عالية المستوى مستقلة عن الآلة. أنها لا تتطلب أي معرفة مسبقة بهندسة الكمبيوتر.

التطبيقات
تتفاعل اللغات ذات المستوى المنخفض مباشرة مع الأجهزة. أنها توفر قدرًا أقل جدًا من المعرفة من الأجهزة أو لا توفرها على الإطلاق. لكنها تشتعل بسرعة كبيرة بالمقارنة مع اللغات عالية المستوى. وبالتالي، يتم استخدامها بشكل عام لتطوير أنظمة التشغيل والأنظمة المدمجة.

توفر اللغات عالية المستوى مستوى أعلى من التجريد من الأجهزة. في الوقت الحاضر، يتم تطوير جميع البرامج تقريبًا باستخدام لغة عالية المستوى. يتم استخدامه لتطوير مجموعة متنوعة من التطبيقات مثل - تطبيقات سطح المكتب ومواقع الويب وبرامج المرافق وتطبيقات الهاتف المحمول وما إلى ذلك.
*********************************************************************************************************************************************
Low level language									High level language
They are faster than high level language.						They are comparatively slower.
Low level languages are memory efficient.						High level languages are not memory efficient.
Low level languages are difficult to learn.						High level languages are easy to learn.
Programming in low level requires additional knowledge of the computer architecture.	 
Programming in high level do not require any additional knowledge of the computer architecture.
They are machine dependent and are not portable.					 They are machine independent and portable.
They provide less or no abstraction from the hardware.					 They provide high abstraction from the hardware.
They are more error prone.								 They are less error prone.
Debugging and maintenance is difficult.							 Debugging and maintenance is comparatively easier.
They are generally used for developing system software’s (Operating systems) and embedded applications.
They are used to develop a variety of applications such as – desktop applications, websites, mobile software’s etc.
********************************************************************************************************************************************
المترجم هو برنامج أو مجموعة من البرامج التي تقوم بتحويل كود المصدر المكتوب بلغة عالية المستوى إلى لغة منخفضة المستوى (لغة التجميع أو لغة الآلة). يمكن أن تحتوي لغة البرمجة على العديد من المترجمين. على سبيل المثال – تعد دول مجلس التعاون الخليجي C، وTurbo C، وQuick C وما إلى ذلك من المترجمين المختلفين للغة البرمجة C.

Language		Compilers			Developed By
C			GCC C				GNU Project
			Borland Turbo C			Embarcadero
			Quick C				Microsoft
******************************************
Language		Compilers			Developed By
C++			GCC				GNU Project
			Borland C++			Borland
			Visual C++			Microsoft
********************************************************************************************************************************************
Compiler and interpreter both are tools to translate source code from high-level language to machine language. Both does the same task of translation. But the working mechanism of compiler is different from interpreter. Below are some differences between compilers and interpreters


Translation mechanism
Compiler reads entire source code and translates to machine language at once. If any error is generated during compilation, it terminates the entire process without executing single instruction.

Whereas interpreters translate instruction-by-instruction. It reads single instruction at a time. Translates it to machine language and executes it. This process continues till the last instruction. If any error is generated during the interpretation, it terminates the execution of further instructions.

Translation time
Compilers reads entire source code at once. It pre-processes, parses, analyses the source code and translates it to machine code at once. Hence, it requires more translation time than interpreters.

Interpreters reads single instruction of source code at a time. Unlike compilers, it doesn’t translate entire source code to machine code at once. Rather it translates the source code, instruction by instruction. Hence, requires less translation time.

Program speed
Compilers translate entire source code at once. After the compilation process, it generates an executable file containing complete instruction set of the program in binary language. Hence, it doesn’t require any further translation which enhances the program execution speed.

Interpreters translate the source code instruction by instruction. It translates single instruction then executes it. Each time before executing an instruction, it must first translate it to machine language. Which increases the overhead of interpretation, hence decreases the program execution speed.

Memory consumption
Compilers usually generate an intermediate code called object code, during the compilation process. Hence it requires more memory than interpreters.

Unlike compilers, interpreters do not generate any intermediate code, during the interpretation process. Thus, interpreters are memory efficient.

Debugging
Compilers continues to process entire source code also if it contains errors. It generates list of all error messages (if any) at the end of the compilation process. Which makes debugging a little difficult.

Interpreters stops the interpretation process if an error is encountered. It generates the error message as the error is met during the interpretation process.

Deployment
Compilers generate an executable file of the source code. This executable file is deployed instead of source code. Which increases the security, by hiding the source code from others.

Interpreters do not generate any executable file of the source code. Therefore, in the case of interpreter’s entire source code needs to be deployed. Causing a security concern as the source code is visible to everyone.
********************************************************************************************************************************************
Compiler								Interpreter
It translates entire program to machine code at once.			It translates single instruction of a program at a time.
It requires more translation time.					It requires less translation time.
Program execution is faster than interpreted languages.			Program execution is slower than compiled languages.
It usually generates additional intermediate code.			It doesn’t generate additional intermediate code.
It requires more memory as it generates extra object code.	     It requires less memory as it does not generate any intermediate code.
Errors are displayed at the end of the compilation process.	     Errors are displayed as they met.
Executable code needs to be deployed.	                 		Source code needs to be deployed.
Example of compiled languages – C, C++, Java etc.  			Example of interpreted languages – Ruby, Python, Shell script etc.
********************************************************************************************************************************************

Syntax Errors:
Syntax errors occur when you violate the rules of the C language syntax. These errors are detected by the compiler during the compilation process.
Example:
int x = 10;
printf("The value of x is %d\n", x)  // Missing semicolon at the end of the statement


Semantic Errors:
Semantic errors occur when the code is grammatically correct but does not behave as intended. These errors can be challenging to detect because they do not cause compilation errors. Instead, they lead to incorrect program behavior or unexpected results.
Example:
int x = 5;
int y = 0;
int result = x / y;  // Division by zero


Runtime Errors:
Runtime errors occur during the execution of a program. These errors may cause the program to terminate abruptly or produce incorrect results. Common runtime errors include division by zero, accessing invalid memory locations, and stack overflow.
Example:
int arr[5];
arr[10] = 42;  // Accessing an out-of-bounds array element


Logical Errors:
Logical errors occur when there is a flaw in the program logic, leading to incorrect output or undesired behavior. These errors are not detected by the compiler or runtime system because the code is syntactically correct.
Example:
int x = 5;
int y = 10;
if (x < y) {
    printf("x is greater than y\n");  // Logical error, should be "x is less than y"
}


********************************************************************************************************************************************
There are five types of tokens.

Keyword
Identifier
Operator
Separator
Literal

********************************************************************************************************************************************
						Various programming paradigms
نموذج البرمجة هو طريقة لتصنيف لغات البرمجة وفقًا لأسلوب البرمجة الخاص بها والميزات التي تقدمها. هناك العديد من الميزات التي تحدد نموذج البرمجة مثل النمطية أو الكائنات أو المقاطعات أو الأحداث أو تدفق التحكم وما إلى ذلك. يمكن أن تكون لغة البرمجة نموذجًا واحدًا أو نماذج متعددة.

ومع الانتشار الواسع للبرمجة، ظهرت نماذج برمجة مختلفة إلى الوجود. بعض نماذج البرمجة الشائعة هي:
						1-Imparetive Programming
						2-Declartive Programming
						3-Structured Programming
						4-Procedurls Programming
						5-OOP        Programming
						6-Functional Programming
*****************************************************************************************************************************************
اللغة منخفضة المستوى والمختصرة بـ LLL، هي لغات قريبة من مجموعة تعليمات مستوى الآلة. أنها توفر تجريدًا أقل أو معدومة من الأجهزة. تتفاعل لغة برمجة منخفضة المستوى مباشرة مع السجلات والذاكرة. نظرًا لأن التعليمات المكتوبة بلغات منخفضة المستوى تعتمد على الآلة. البرامج التي تم تطويرها باستخدام لغات منخفضة المستوى تعتمد على الآلة وليست محمولة.


لا تتطلب اللغة ذات المستوى المنخفض أي مترجم أو مترجم فوري لترجمة المصدر إلى كود الآلة. قد يقوم المجمع بترجمة كود المصدر المكتوب بلغة منخفضة المستوى إلى كود الآلة.

البرامج المكتوبة بلغات منخفضة المستوى سريعة وفعالة في الذاكرة. ومع ذلك، فمن الكابوس بالنسبة للمبرمجين كتابة البرامج ذات المستوى المنخفض وتصحيح أخطائها وصيانتها. يتم استخدامها في الغالب لتطوير أنظمة التشغيل وبرامج تشغيل الأجهزة وقواعد البيانات والتطبيقات التي تتطلب الوصول المباشر إلى الأجهزة.

يتم تصنيف اللغات منخفضة المستوى أيضًا إلى فئتين أخريين – لغة الآلة ولغة التجميع.
******************************************************************************************************************************************
لغة الآلة
لغة الآلة هي اللغة الأقرب إلى الأجهزة. وتتكون من مجموعة من التعليمات التي يتم تنفيذها مباشرة بواسطة الكمبيوتر. هذه التعليمات عبارة عن سلسلة من البتات الثنائية. تؤدي كل تعليمات مهمة محددة وصغيرة جدًا. التعليمات المكتوبة بلغة الآلة تعتمد على الآلة وتختلف من كمبيوتر إلى آخر.

مثال: SUB AX, BX = 00001011 00000001 00100010 عبارة عن مجموعة تعليمات لطرح قيم مسجلين AX وBX.

في الأيام الأولى للبرمجة، كان البرنامج يُكتب بلغة الآلة فقط. تمت كتابة كل البرامج كسلسلة من الثنائيات.

يجب أن يكون لدى المبرمج معرفة إضافية حول بنية جهاز معين، قبل البرمجة بلغة الآلة. يعد تطوير البرامج باستخدام لغة الآلة مهمة شاقة. نظرًا لأنه من الصعب جدًا تذكر تسلسل الثنائيات لمختلف بنيات الكمبيوتر. ولذلك، في الوقت الحاضر ليس كثيرا في الممارسة العملية.

لغة التجميع
لغة التجميع هي تحسين على لغة الآلة. كما هو الحال مع لغة الآلة، تتفاعل لغة التجميع أيضًا بشكل مباشر مع الأجهزة. بدلاً من استخدام التسلسل الثنائي الخام لتمثيل مجموعة التعليمات، تستخدم لغة التجميع فن الإستذكار.

فن الإستذكار عبارة عن كلمات إنجليزية قصيرة ومختصرة تستخدم لتحديد تعليمات الكمبيوتر. كل تعليمات في النظام الثنائي لها تذكير محدد. إنها تعتمد على الهندسة المعمارية وهناك قائمة من أساليب الإستذكار المنفصلة لمختلف بنيات الكمبيوتر.

من أمثلة فن الإستذكار – ADD، MOV، SUB وما إلى ذلك.

أعطت أساليب تقوية الذاكرة راحة للمبرمجين من تذكر التسلسل الثنائي للحصول على تعليمات محددة. نظرًا لأنه من السهل تذكر الكلمات الإنجليزية مثل ADD وMOV وSUB، مقارنةً بالتسلسل الثنائي 10001011. ومع ذلك، لا يزال يتعين على المبرمج أن يتذكر العديد من أساليب الإستذكار لمختلف بنيات الكمبيوتر.

تستخدم لغة التجميع برنامجًا خاصًا يسمى المجمع. يقوم المجمع بترجمة أساليب الإستذكار إلى رمز جهاز محدد.

لغة التجميع لا تزال قيد الاستخدام. يتم استخدامه لتطوير أنظمة التشغيل وبرامج تشغيل الأجهزة والمترجمين والبرامج الأخرى التي تتطلب الوصول المباشر إلى الأجهزة.
******************************************************************************************************************************************
Advantages of low level languages
Programs developed using low level languages are fast and memory efficient.
Programmers can utilize processor and memory in better way using a low level language.
There is no need of any compiler or interpreters to translate the source to machine code. Thus, cuts the compilation and interpretation time.
Low level languages provide direct manipulation of computer registers and storage.
It can directly communicate with hardware devices.

Disadvantages of low level languages
Programs developed using low level languages are machine dependent and are not portable.
It is difficult to develop, debug and maintain.
Low level programs are more error prone.
Low level programming usually results in poor programming productivity.
Programmer must have additional knowledge of the computer architecture of particular machine, for programming in low level language.
********************************************************************************************************************************************
					ARRAY
المصفوفة عبارة عن بنية بيانات تحتوي على مجموعة متسلسلة محدودة من البيانات المتجانسة.

لتبسيط الأمر، دعونا نكسر الكلمات.

المصفوفة عبارة عن مجموعة - المصفوفة عبارة عن حاوية يمكنها الاحتفاظ بمجموعة من البيانات.
المصفوفة محدودة – مجموعة البيانات في المصفوفة تكون دائمًا محدودة، ويتم تحديدها قبل استخدامها.
المصفوفة تسلسلية - تقوم المصفوفة بتخزين مجموعة من البيانات بشكل تسلسلي في الذاكرة.
يحتوي الصفيف على بيانات متجانسة - يجب أن تشترك مجموعة البيانات في الصفيف في نفس نوع البيانات.

يمكننا تقسيم المصفوفات إلى فئتين.

مصفوفة أحادية البعد (أو مصفوفة أحادية البعد)
مصفوفة متعددة الأبعاد


لماذا نحتاج المصفوفات؟
دعونا نفهم أهمية المصفوفات من خلال مثال.

لنفترض أنني طلبت منك كتابة برنامج لإدخال 1000 علامة طالب من المستخدم. وأخيرا طباعة متوسط علاماتهم.

لحل المشكلة سوف تعلن 1000 عدد صحيح متغير لعلامات الإدخال. قم باستدعاء وظائف الإدخال/الإخراج لإدخال العلامات في 1000 متغير وأخيرًا ابحث عن المتوسط.

فكر لبعض الوقت في مدى صعوبة البرمجة إذا تم حلها باستخدام الطريقة المذكورة أعلاه. أعلن عن 1000 متغير، وقم بإدخال جميع المتغيرات، ثم ابحث عن المتوسط، وأخيرًا اطبع متوسطه. ما ورد أعلاه يزيد من طول التعليمات البرمجية والتعقيد ويخفض الأداء. إذا كنت لا تصدق، حاول ترميز الحل باستخدام الطريقة المذكورة أعلاه.

لحل المشكلة المذكورة أعلاه بكفاءة نستخدم المصفوفات. المصفوفات جيدة في التعامل مع جمع البيانات (جمع 1000 علامة طالب). ضع في اعتبارك أنه في البرمجة، سنستخدم دائمًا بعض هياكل البيانات (المصفوفة في حالتنا) للتعامل مع مجموعة من البيانات بكفاءة.



How to initialize an array?
There are two ways to initialize an array.

Static array initialization – Initializes all elements of array during its declaration.
Dynamic array initialization – The declared array is initialized some time later during execution of program.


Static initialization of array
We define value of all array elements within a pair of curly braces { and } during its declaration. Values are separated using comma , and must be of same type.

Example of static array initialization
int marks[5] = {90, 86, 89, 76, 91};

Note: Size of array is optional when declaring and initializing array at once. The C compiler automatically determines array size using number of array elements. Hence, you can write above array initialization as.

int marks[] = {90, 86, 89, 76, 91};




Dynamic initialization of array
You can assign values to an array element dynamically during execution of program. First declare array with a fixed size. Then use the following syntax to assign values to an element dynamically.

array_name[index] = some_value;
marks[0] = 90; // Assigns 90 to first element of marks array
marks[1] = 86; // Assigns 86 to second element of marks array
...
...
...
marks[4] = 91; // Assigns 91 to fifth element of marks array

Instead of hard-coding marks values, you can ask user to input values to array using scanf() function.

scanf("%d", &marks[0]); // Input an integer from user and assigns to first element of marks

scanf("%d", &marks[4]); // Input an integer from user and assigns to fifth element of marks
The array index is an integer value, so instead of hard-coding you can wrap array input code inside a loop.

int index;

// Run a loop from 0 to 4
for(index = 0; index < 5; index++)
{
    // Replace the hard-coded index with 'index' variable
    scanf("%d", &marks[index]);
}
The above code will run 5 times from 0 to 4. In each iteration it ask user to input an integer and stores it in successive elements of marks array.









Multi-dimensional array is an array of array or more precisely collection of array. Unlike one-dimensional array, multi-dimensional array stores collection of array.

Let us revise the concept of dimension.

One-dimensional array : Collection of data/values.
Two-dimensional array : Collection of one-dimensional array.
Three-dimensional array : Collection of two-dimensional array.
N-dimensional array : Collection of N-1 dimensional array.

We can declare array with any dimension. However, two-dimensional array is most popular and widely used to solve many mathematical problems.

Note: Whether it is one, two or N-dimensional array. All array elements are stored sequentially in memory.


Syntax to declare two-dimensional array
type array_name[row-size][col-size];
type is a valid C data type.
array_name is a valid C identifier that denotes name of the array.
row-size is a constant that specifies matrix row size.
col-size is also a constant that specifies column size. col-size is optional when initializing array during its declaration.


How to initialize two-dimensional array
You can initialize a two-dimensional array in any of the given form.

int matrix[4][3] = {
                       {10, 20, 30},    // Initializes matrix[0]
                       {40, 50, 60},    // Initializes matrix[1]
                       {70, 80, 90},    // Initializes matrix[2]
                       {100, 110, 120}  // Initializes matrix[3]
                   };
If you have mentioned row and column size specifically then curly braces for each row inside array initialization is optional. Hence, you can write the above initialization as.

int matrix[4][3] = {10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120};
Note: Be cautious while using the above approach to initialize. You must explicitly provide row and column size. Otherwise C compiler will generate compilation errors.

Array column size is optional if specifying individual rows within pair of curly braces.
int matrix[4][] = {
                       {10, 20, 30},    // Initializes matrix[0]
                       {40, 50, 60},    // Initializes matrix[1]
                       {70, 80, 90},    // Initializes matrix[2]
                       {100, 110, 120}  // Initializes matrix[3]
                   };
There are several ways to initialize a two-dimensional array. It depends on programmers how they initialize. However, the first approach is considered as standard to initialize a two-dimensional array.







Example to access two-dimensional array
matrix[0][0] = 10;  // Assign 10 to first element of first row
matrix[0][1] = 20;  // Assign 20 to second element of first row
matrix[1][2] = 60;  // Assign 60 to third element of second row
matrix[3][0] = 100; // Assign 100 to first element of fourth row
Since array indexes are integer value, hence you can also wire a loop to access two-dimensional array. Two-dimensional array needs two index values to access any array element. Therefore you need two loops. One outer loop to access for each row of the matrix, second loop for each column of the matrix.


// Runs 4 times iterating through each row
for(i=0; i<4; i++)
{
    // Runs 3 times for each row.
    for(j=0; j<3; j++)
    {
        scanf("%d", &matrix[i][j]);
    }
}

/**
 * C program to input and display three-dimensional array
 */

#include <stdio.h>

#define SIZE1 2
#define SIZE2 2
#define SIZE3 3

int main()
{
    int arr[SIZE1][SIZE2][SIZE3];
    int i, j, k;

    /*
     * Input elements in array
     */
    printf("Enter elements in three-dimensional array of size %dx%dx%d \n", SIZE1, SIZE2, SIZE3);
    for(i = 0; i < SIZE1; i++)
    {
        for(j = 0; j < SIZE2; j++)
        {
        	for (k = 0; k < SIZE3; k++)
        	{
            	scanf("%d", &arr[i][j][k]);	
        	}
        }
    }

    /*
     * Print elements of array
     */
    printf("\nElements in three-dimensional array are: \n");
    for(i = 0; i < SIZE1; i++)
    {
        for(j = 0; j < SIZE2; j++)
        {
        	for (k = 0; k < SIZE3; k++)
        	{
            	printf("%d\n", arr[i][j][k]);	
        	}
        }
    }

    return 0;
}
*********************************************************************************************************************************************
							ARRAYS AND FUNCTION IN C
Array is a data structure to store homogeneous collection of data. Arrays are equally important as functions. In programming we often use arrays and functions together.


How to pass single dimensional array to function?
In C you can pass single dimensional arrays in two ways. You can either pass it directly to a function. Or you can also pass it as a pointer to array.

Let us see both ways to pass single dimensional array to function one after one.

1. Passing array directly to function
You can pass single dimensional array directly to functions as you pass other variables.
void printArray(int arr[], int size)
{
    int i;

    printf("Array elements are: ");
    for(i = 0; i < size; i++)
    {
        printf("%d, ", arr[i]);
    }
}

int main()
{
    int arr[5];

    printArray(arr, 5);    // Pass array directly to function printArray

    return 0;
}



2. Passing array using pointer
Since array and pointers are closely related to each other. Hence you can also pass an array to function as pointer.


void printArray(int * arr, int size)
{
    int i;

    printf("Array elements are: ");
    for(i = 0; i < size; i++)
    {
        printf("%d, ", arr[i]);
    }
}

int main()
{
    int arr[5];

    printArray(arr, 5);    // Pass array directly to function printArray

    return 0;
}
Important Note: Arrays in C are passed as reference not by value. Which means any changes to array within the function will also persist outside the function.











كيفية إرجاع مجموعة أحادية البعد من الوظيفة؟
في لغة C لا يمكنك إرجاع مصفوفة مباشرة من دالة. لكن هذا لا يفرض قيودًا على لغة C. هناك طريقتان لإرجاع مصفوفة بشكل غير مباشر من دالة.

1. Return pointer pointing at array from function
C does not allow you to return array directly from function. However, you can return a pointer to array from function.
Let us write a program to initialize and return an array from function using pointer.


#include <stdio.h>

/**
 * Function to return an array using pointers.
 * @return 	Pointer to array 
 */ 
int * getArray()
{
    int num[] = {1, 2, 3, 4, 5};
    int i;

    printf("Array inside function: ");
    // Print value of each array element
    for (i = 0; i < 5; ++i)
    {
        printf("%d\n", num[i]);
    }

    return num;
}

int main()
{
    int i;

    // Pointer to store array
    int * num;

    // Call getArray function to get pointer to array
    num = getArray();

    printf("Array outside function: \n");
    // Print value of each array element
    for (i = 0; i < 5; ++i)
    {
        printf("%d\n", num[i]);
    }

    return 0;
}

C compiler reports a warning message on compilation of above program.

a.c: In function 'getArray':
a.c:12:5: warning: function returns address of local variable [-Wreturn-local-addr]
     return num;
     ^
It complains about returning address of a local variable. We can return value of a local variable but it is illegal to return memory location that is allocated within function on stack. Since, after program control is returned from the function all variables allocated on stack within function are freed. Hence, returning a memory location which is already released will point at no man’s land.

But overlooking the compilers warning message let us run the program. On execution it produces following output which is somewhat weird.

Array inside function: 1
2
3
4
5
Array outside function: 3043328
8
6356668
4
6356940 
It is clear that inside function our array successfully got initialized, but something awful happened after returning it from function.

To overcome this you can either allocate array dynamically using malloc() function. Or declare array within function as static variable. Or you can pass the array to be returned as a parameter to the function.

However the best practice is to either pass array to return as parameter or allocate array dynamically using malloc() function.








2. Pass the returned array as parameter
#include <stdio.h>

#define MAX_SIZE 10

/* Function delcaration to initialize array and return */
void getArray(int arr[], int size);

int main()
{
    int arr[MAX_SIZE];
    int i;

    // Call function to initialize array.
    getArray(arr, MAX_SIZE);

    printf("\n\nArray outside function: \n");
    for (i = 0; i < MAX_SIZE; i++)
    {
        printf("%d ", arr[i]);
    }

    return 0;
}

/** 
 * Function to initialize array.
 *
 * @arr     Integer array to initialize and return.
 * @size    Size of the array.
 */
void getArray(int arr[], int size)
{
    int i;

    printf("Enter elements in array: ");
    for (i = 0; i < size; i++)
    {
        scanf("%d", &arr[i]);
    }

    printf("\n\nArray inside function: \n");
    for (i = 0; i < size; i++)
    {
        printf("%d ", arr[i]);
    }
}


How to pass multi-dimensional array to function?
Multi-dimensional arrays are passed in the same fashion as single dimensional. Which means you can pass multi-dimensional array to a function in two ways.

1. Passing multi-dimensional array directly to function
This is the simplest way to pass a multi-dimensional array to functions. Pass the array as other variables.
#include <stdio.h>

#define ROWS 3
#define COLS 3

/* Function declaration to print two dimensional array */
void printMatrix(int mat[][COLS]);

int main()
{
    int mat[ROWS][COLS] = {
                            {1, 2, 3}, 
                            {4, 5, 6},
                            {7, 8, 9}
                          };

    // Print elements of matrix using function
    printMatrix(mat);    

    return 0;
}

/** 
 * Function to accept two dimensional array and print
 * its elements.
 * 
 * @mat     Two dimensional integer array to print.
 */
void printMatrix(int mat[][COLS])
{
    int i, j;

    // Print elements of two dimensional array.
    printf("Elements in matrix: \n");
    for (i = 0; i < ROWS; i++)
    {
        for (j = 0; j < COLS; j++)
        {
            printf("%d ", mat[i][j]);
        }
        printf("\n");
    }
}



2. Passing multi-dimensional array to function using pointer
#include <stdio.h>

#define ROWS 3
#define COLS 3

/* Function declaration */
void inputMatrix(int (*mat)[COLS]);
void printMatrix(int mat[][COLS]);

int main()
{
    int mat[ROWS][COLS];

    // Input elements in matrix using function
    inputMatrix(mat);

    // Print elements of matrix using function
    printMatrix(mat);    

    return 0;
}

/**
 * Function to accept a two dimensional array and input
 * elements in matrix from user.
 * 
 * @mat     Two dimensional integer array to store user input.
 */
void inputMatrix(int (*mat)[COLS])
{
    int i, j;

    // Input elements in 2D matrix
    printf("Enter elements in 2D matrix: \n");
    for (i = 0; i < ROWS; i++)
    {
        for (j = 0; j < COLS; j++)
        {
            scanf("%d", (*(mat + i) + j));
        }
    }
}

/** 
 * Function to accept a two dimensional array and print
 * its elements.
 * 
 * @mat     Two dimensional integer array to print.
 */
void printMatrix(int (*mat)[COLS])
{
    int i, j;

    // Print elements of two dimensional array.
    printf("Elements in matrix: \n");
    for (i = 0; i < ROWS; i++)
    {
        for (j = 0; j < COLS; j++)
        {
            printf("%d ", *(*(mat + i) + j));
        }
        printf("\n");
    }
}

Important Note: int (*mat)[COLS] and int * mat[COLS] both are different. First is a pointer to array whereas second is array of pointers.

How to return multi-dimensional array from function?
Returning multi-dimensional array from function is similar as of returning single dimensional array. Which means you can either return a pointer to array or pass the array to return as a function parameter.

#include <stdio.h>

#define ROWS 3
#define COLS 3

/* Function declaration */
void matrixAddition(int mat1[][COLS], int mat2[][COLS], int res[][COLS]);
void printMatrix(int mat[][COLS]);

int main()
{
    int mat1[ROWS][COLS] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
    int mat2[ROWS][COLS] = {{1, 1, 1}, {2, 2, 2}, {3, 3, 3}};    

    // Resultant matrix which is passed to function. 
    // Function performs calculation and fills the array
    int res[ROWS][COLS];

    // Input elements in matrix using function
    matrixAddition(mat1, mat2, res);

    // Print resultant array
    printMatrix(res);    

    return 0;
}

/**
 * Function to add two matrices and return the resultant matrix.
 * 
 * @mat1    First matrix to add.
 * @mat2    Second matrix to add.
 * @res     The resultant matrix that will be filled with addition 
 *          result.
 */
void matrixAddition(int mat1[][COLS], int mat2[][COLS], int res[][COLS])
{
    int i, j;
    for(i = 0; i < ROWS; i++)
    {
        for(j = 0; j < COLS; j++)
        {
            res[i][j] = mat1[i][j] + mat2[i][j];
        }
    }
}

/** 
 * Function to accept a two dimensional array and print
 * its elements.
 * 
 * @mat     Two dimensional integer array to print.
 */
void printMatrix(int mat[][COLS])
{
    int i, j;

    // Print elements of two dimensional array.
    printf("Elements in matrix: \n");
    for (i = 0; i < ROWS; i++)
    {
        for (j = 0; j < COLS; j++)
        {
            printf("%d ", mat[i][j]);
        }
        printf("\n");
    }
}

خاتمة
لقد تعلمنا تمرير المصفوفة وإرجاع المصفوفة من دالة. إن تمرير مصفوفة إلى وظيفة ليس بالأمر الكبير ويتم تمريره كمتغيرات أخرى. ولكن ضع في اعتبارك دائمًا أن المصفوفات يتم تمريرها حسب المرجع. إن إرجاع مصفوفة من الوظيفة ليس بنفس سهولة تمرير المصفوفة إلى الوظيفة. هناك طريقتان لإرجاع مصفوفة من الوظيفة. لكنني شخصياً أفضل تمرير المصفوفة للعودة كوسيطة وملء المصفوفة الناتجة داخل الوظيفة بالنتيجة المعالجة.
*********************************************************************************************************************************************
							

